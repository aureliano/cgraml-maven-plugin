package com.github.aureliano.srvraml.code.builder;

import java.io.File;
import java.util.HashMap;
import java.util.Map;

import org.apache.commons.lang.StringUtils;

import com.github.aureliano.srvraml.code.meta.ClassMeta;
import com.github.aureliano.srvraml.code.meta.FieldMeta;
import com.github.aureliano.srvraml.code.meta.MethodMeta;
import com.github.aureliano.srvraml.helper.CodeBuilderHelper;
import com.sun.codemodel.JCodeModel;
import com.sun.codemodel.JDefinedClass;
import com.sun.codemodel.JMethod;

public class ModelBuilder implements IBuilder {

	private ClassMeta clazz;
	
	protected ModelBuilder() {
		super();
	}
	
	@SuppressWarnings("unchecked")
	@Override
	public ModelBuilder parse(String pkg, String entity, String json) {
		Map<?, ?> map = this.parseJsonString(json);
		Map<String, Map<String, String>> properties = (Map<String, Map<String, String>>) map.get("properties");
		
		String javaDoc = new StringBuilder()
			.append("Generated by srvraml-maven-plugin.")
			.append("\n\n")
			.append(map.get("description"))
			.toString();
		
		this.clazz = new ClassMeta()
			.withPackageName(pkg + ".model")
			.withJavaDoc(javaDoc)
			.withClassName(StringUtils.capitalize(entity));
		
		for (String fieldName : properties.keySet()) {
			Map<String, String> property = properties.get(fieldName);
			property.put("name", fieldName);
			FieldMeta attribute = FieldMeta.parse(property);
			
			this.clazz
				.addField(attribute)
				.addMethod(CodeBuilderHelper.createGetterMethod(attribute))
				.addMethod(CodeBuilderHelper.createSetterMethod(attribute));
		}

		return this;
	}
	
	@SuppressWarnings("unchecked")
	@Override
	public ModelBuilder build() {
		this.buildJavaClass();		
		return this;
	}
	
	private void buildJavaClass() {
		try {
			JCodeModel codeModel = new JCodeModel();
			JDefinedClass definedClass = codeModel._class(this.clazz.getCanonicalClassName());
			definedClass.javadoc().append(this.clazz.getJavaDoc());
			
			this.appendClassAttributes(definedClass);
			this.appendClassMethods(codeModel, definedClass);
			
			codeModel.build(new File("src/main/java"));
		} catch (Exception ex) {
			throw new RuntimeException(ex);
		}
	}
	
	private void appendClassMethods(JCodeModel codeModel, JDefinedClass definedClass) {
		for (MethodMeta method : this.clazz.getMethods()) {
			if (method.getReturnType() == null) {
				JMethod jm = definedClass.method(method.getVisibility().getMod(), codeModel.VOID, method.getName());
				FieldMeta param = method.getParameters().get(0);
				
				jm.param(param.getType(), param.getName());
				jm.body().directStatement(method.getBody());
			} else {
				JMethod jm = definedClass.method(method.getVisibility().getMod(), method.getReturnType(), method.getName());
				jm.body().directStatement(method.getBody());
			}
		}
	}

	private void appendClassAttributes(JDefinedClass definedClass) {
		for (FieldMeta field : this.clazz.getFields()) {
			definedClass.field(field.getVisibility().getMod(), field.getType(), field.getName());
		}
	}

	private Map<?, ?> parseJsonString(String json) {
		try {
			return OBJECT_MAPPER.readValue(json, HashMap.class);
		} catch (Exception ex) {
			throw new RuntimeException(ex);
		}
	}
	
	public ClassMeta getClazz() {
		return clazz;
	}
	
	public ModelBuilder withClazz(ClassMeta clazz) {
		this.clazz = clazz;
		return this;
	}
}